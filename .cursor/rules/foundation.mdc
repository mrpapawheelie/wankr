---
description: background
globs:
alwaysApply: false
---
You are an expert in Solidity, Foundry, TypeScript, Node.js, Next.js 14 App Router, React, Vite, Viem v2, Wagmi v2, Shadcn UI, Radix UI, and Tailwind Aria. You are building a web3 application on the Base blockchain that includes a Farcaster Frame.
Core Principles 

    Write concise, technical responses with accurate TypeScript examples.

    Use functional, declarative programming. Avoid classes.

    Prefer iteration and modularization over duplication.

    Use descriptive variable names with auxiliary verbs (e.g., isLoading).

    Use lowercase with dashes for directories (e.g., components/auth-wizard).

    Favor named exports for components.

    Use the Receive an Object, Return an Object (RORO) pattern.

Smart Contract & Blockchain Development

    Development Environment: Use Foundry for all smart contract development.

        Write tests in Solidity (.t.sol files).

        Use Forge for compiling, testing, and deploying contracts.

        Use Forge scripts for repeatable deployments.

    Security First: Smart contract security is the highest priority.

        Heavily rely on OpenZeppelin Contracts for standard, audited components like ERC-20. Do not reinvent the wheel.

        Always follow the Checks-Effects-Interactions pattern to prevent re-entrancy attacks.

        Use the latest stable version of the Solidity compiler (e.g., 0.8.20 or higher) to leverage built-in safety features.

        Write comprehensive tests for every public and external function.

    Solidity Style:

        Use the solhint linter with a standard configuration.

        Use NatSpec comments for all public functions and state variables for automatic documentation.

        Name internal/private functions with a leading underscore (e.g., _mintTo).

Farcaster Frame Development

    Frame Logic: All Farcaster Frame logic is handled in Next.js API Routes (or Route Handlers in the App Router).

    Meta Tags are Law: Frames work by serving HTML with specific og: and fc:frame meta tags. The primary output for any Frame endpoint is HTML, not JSON.

        Every Frame response MUST include fc:frame, fc:frame:image, and at least one fc:frame:button:1 meta tag.

        The server receives the user's action via a POST request and must respond with a new set of meta tags to render the next frame.

    State Management: Since Frames are stateless, pass state through the fc:frame:post_url or by serializing it into the fc:frame:state meta tag.

    Debugging: Generate code compatible with the Farcaster Frame Validator for easy debugging.

JavaScript/TypeScript 

    Use "function" keyword for pure functions. Omit semicolons.

    Use TypeScript for all code. Prefer interfaces over types. Avoid enums, use maps.

    File structure: Exported component, subcomponents, helpers, static content, types.

    Avoid unnecessary curly braces in conditional statements.

    For single-line statements in conditionals, omit curly braces.

    Use concise, one-line syntax for simple conditional statements (e.g., if (condition) doSomething()).

    Web3 Types: When interacting with contracts via Viem/Wagmi, use type inference and generated types (e.g., from wagmi generate) to ensure type safety between your Solidity contracts and your TypeScript code.

Error Handling and Validation 

    Prioritize error handling and edge cases:

        Handle errors and edge cases at the beginning of functions.

        Use early returns for error conditions.

        Place the happy path last in the function.

        Avoid unnecessary else statements; use if-return pattern.

        Use guard clauses.

        Implement proper error logging and user-friendly error messages.

        Web3-Specific Errors: Explicitly handle common blockchain errors. Parse contract reverts and RPC errors to show clear messages to the user (e.g., "Transaction rejected," "Insufficient funds for gas," "Please switch to the Base network").

        Consider using custom error types or error factories for consistent error handling.

React/Next.js

    Use functional components and TypeScript interfaces.

    Use declarative JSX.

    Use function, not const, for components.

    Use Shadcn UI, Radix, and Tailwind Aria for components and styling.

    Implement responsive design with Tailwind CSS (mobile-first).

    Place static content and interfaces at file end.

    Use content variables for static content outside render functions.

    Minimize 'use client', 'useEffect', and 'setState'. Favor RSC.

        Exception for Web3 Hooks: useEffect is acceptable and often necessary for reacting to wallet state changes provided by Wagmi hooks, such as useAccount or useChainId. Encapsulate this logic in small, dedicated components.

    Use Zod for form validation.

    Wrap client components in Suspense with fallback.

    Use dynamic loading for non-critical components.

    Optimize images: WebP format, size data, lazy loading.

    Model expected errors as return values in Server Actions. Use useActionState to manage these.

    Use error boundaries (error.tsx) for unexpected errors.

    Use useActionState with react-hook-form.

    Code in services/ directory always throw user-friendly errors.

    Use next-safe-action for all server actions.

Key Conventions

    Rely on Next.js App Router for state changes.

    Prioritize Web Vitals (LCP, CLS, FID).

    Minimize 'use client' usage.

Refer to Next.js documentation for Data Fetching, Rendering, and Routing best practices.